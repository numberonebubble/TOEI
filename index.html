<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Odd Earth Institute</title>
    <style>
        /* --- ECO-FUTURIST / BLUEPRINT CSS --- */
        :root {
            --bg-color: #051020; /* Deep Blueprint Blue */
            --primary: #00ffcc;  /* Eco-Cyan */
            --secondary: #ffce00; /* Warning Yellow (Industrial) */
            --text-dim: #8892b0;
            --grid-line: rgba(0, 255, 204, 0.1);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: white;
            font-family: 'Courier New', Courier, monospace; /* Monospace for blueprint feel */
            overflow-x: hidden;
        }

        /* The Canvas */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Blueprint Grid Overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            background-image: 
                linear-gradient(var(--grid-line) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none; /* Let clicks pass through */
        }

        /* UI Elements */
        .hud-corner {
            position: fixed;
            padding: 20px;
            z-index: 3;
            font-size: 12px;
            letter-spacing: 2px;
            color: var(--primary);
            pointer-events: none;
        }
        .top-left { top: 0; left: 0; border-right: 1px solid var(--primary); border-bottom: 1px solid var(--primary); }
        .bottom-right { bottom: 0; right: 0; border-left: 1px solid var(--primary); border-top: 1px solid var(--primary); }

        /* Scroll Content */
        main {
            position: relative;
            z-index: 4;
        }

        section {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Left align for workshop feel */
            padding-left: 10%;
            padding-right: 10%;
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 1s ease;
        }

        section.visible {
            opacity: 1;
        }

        .content-box {
            background: rgba(5, 16, 32, 0.85);
            border: 1px solid var(--primary);
            padding: 2rem;
            max-width: 500px;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.1);
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            color: var(--white);
        }

        h2 {
            font-size: 1.5rem;
            color: var(--secondary);
            margin-bottom: 1rem;
        }

        p {
            line-height: 1.6;
            color: var(--text-dim);
        }

        .tagline {
            color: var(--primary);
            font-weight: bold;
            border-bottom: 1px dashed var(--primary);
            display: inline-block;
            margin-bottom: 20px;
        }

        /* Scroll indicator */
        .scroll-indicator {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateY(0) translateX(-50%);}
            40% {transform: translateY(-10px) translateX(-50%);}
            60% {transform: translateY(-5px) translateX(-50%);}
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="overlay"></div>
    <div class="hud-corner top-left">ODD EARTH INST.<br>SYS.STATUS: ONLINE</div>
    <div class="hud-corner bottom-right">LATERAL THINKING<br>WITHERED TECH</div>

    <main>
        <section id="s1" class="visible">
            <div class="content-box">
                <span class="tagline">The Garage Workshop</span>
                <h1>Odd Earth</h1>
                <p>We don't need new physics to save the world. We just need to use what we already have, differently.</p>
                <div class="scroll-indicator">▼</div>
            </div>
        </section>

        <section id="s2">
            <div class="content-box" style="margin-left: auto;"> <span class="tagline">Philosophy</span>
                <h2>The Yokoi Method</h2>
                <p>Inspired by the creator of the Game Boy. We utilize "Withered Technology"—cheap, mature, and well-understood tech—to engineer radical solutions.</p>
            </div>
        </section>

        <section id="s3">
            <div class="content-box">
                <span class="tagline">Methodology</span>
                <h2>MacGyver Engineering</h2>
                <p>A paperclip and a microcontroller. High impact, low resource intensity. We build modular, repairable systems designed for the real world, not a lab.</p>
            </div>
        </section>

        <section id="s4">
            <div class="content-box" style="margin-left: auto; text-align: center;">
                <span class="tagline">Target</span>
                <h2>Global Scale</h2>
                <p>Crystallizing chaotic data into actionable climate solutions. The future isn't shiny chrome; it's green, patched together, and it works.</p>
            </div>
        </section>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 8000;
        const PARTICLE_SIZE = 0.08;
        const MORPH_SPEED = 0.05;

        // --- SETUP THREE.JS ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // Fog to blend particles into the deep blue background
        scene.fog = new THREE.FogExp2(0x051020, 0.03);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // --- PARTICLE SYSTEM ---
        
        // We need arrays to store positions for different shapes
        // 0: Chaos, 1: GameBoy (Yokoi), 2: Gear (MacGyver), 3: Globe (Earth)
        const shapes = {
            chaos: [],
            gameboy: [],
            gear: [],
            globe: []
        };

        // Helper to generate random coordinates
        const rand = (min, max) => Math.random() * (max - min) + min;

        // 1. GENERATE CHAOS (Random Field)
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            shapes.chaos.push(rand(-40, 40), rand(-40, 40), rand(-30, 30));
        }

        // 2. GENERATE GAMEBOY (Rectangle with cutout)
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let x, y, z;
            // Simple logic: weighted distribution to form a box shape
            if (i < PARTICLE_COUNT * 0.8) {
                // Body
                x = rand(-6, 6);
                y = rand(-9, 9);
                z = rand(-1, 1);
            } else {
                // Screen area (denser)
                x = rand(-4, 4);
                y = rand(1, 6);
                z = rand(1.5, 2.5); // Pop out slightly
            }
            shapes.gameboy.push(x, y, z);
        }

        // 3. GENERATE GEAR (Torus/Ring)
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const angle = Math.random() * Math.PI * 2;
            // Radius varies to create thickness + teeth
            let radius = 7 + Math.random() * 2; 
            
            // Add teeth every 45 degrees
            const teeth = 8;
            const toothAngle = (Math.PI * 2) / teeth;
            if (Math.abs(angle % toothAngle) < 0.2) {
                radius += 2.5; // Tooth extension
            }

            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            const z = rand(-1, 1);
            shapes.gear.push(x, y, z);
        }

        // 4. GENERATE GLOBE (Sphere)
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            const r = 9;

            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = r * Math.cos(phi);
            shapes.globe.push(x, y, z);
        }

        // --- INITIALIZE GEOMETRY ---
        const geometry = new THREE.BufferGeometry();
        const currentPositions = new Float32Array(shapes.chaos); // Start with chaos
        
        // We use a "target" attribute to know where particles want to go
        const targetPositions = new Float32Array(shapes.chaos);

        geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
        
        // Create Material - Eco Cyan/Green Color
        const material = new THREE.PointsMaterial({
            color: 0x00ffcc,
            size: PARTICLE_SIZE,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- SCROLL & MORPH LOGIC ---

        // Sections trigger shape changes
        const sections = document.querySelectorAll('section');
        let currentShapeIndex = 0;

        function updateTargetShape(index) {
            let targetArray;
            switch(index) {
                case 0: targetArray = shapes.chaos; break;
                case 1: targetArray = shapes.gameboy; break;
                case 2: targetArray = shapes.gear; break;
                case 3: targetArray = shapes.globe; break;
                default: targetArray = shapes.chaos;
            }

            // Update the array that particles are trying to reach
            for (let i = 0; i < targetArray.length; i++) {
                targetPositions[i] = targetArray[i];
            }
        }

        // Scroll Handler
        window.addEventListener('scroll', () => {
            const scrollY = window.scrollY;
            const windowH = window.innerHeight;
            
            // Determine active section
            const newIndex = Math.round(scrollY / windowH);
            
            if (newIndex !== currentShapeIndex && newIndex < 4) {
                currentShapeIndex = newIndex;
                updateTargetShape(currentShapeIndex);
            }

            // Fade in/out text sections
            sections.forEach((sec, idx) => {
                const rect = sec.getBoundingClientRect();
                if (rect.top < windowH * 0.75 && rect.bottom > windowH * 0.25) {
                    sec.classList.add('visible');
                } else {
                    sec.classList.remove('visible');
                }
            });
        });

        // --- ANIMATION LOOP ---
        
        // Mouse interaction for subtle parallax
        let mouseX = 0;
        let mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX - window.innerWidth / 2) * 0.001;
            mouseY = (e.clientY - window.innerHeight / 2) * 0.001;
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const positions = particleSystem.geometry.attributes.position.array;

            // Loop through particles
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;

                // 1. Interpolation Logic (Morphing)
                // Move current position towards target position
                positions[i3]     += (targetPositions[i3]     - positions[i3])     * MORPH_SPEED;
                positions[i3 + 1] += (targetPositions[i3 + 1] - positions[i3 + 1]) * MORPH_SPEED;
                positions[i3 + 2] += (targetPositions[i3 + 2] - positions[i3 + 2]) * MORPH_SPEED;

                // 2. Fluidity / Noise
                // Add a sine wave drift so particles are never truly still (The "Living" Field)
                // We use the index 'i' to make the movement uneven across the field
                if (currentShapeIndex === 0) {
                     // Chaos state moves more
                    positions[i3]     += Math.sin(time + i) * 0.02;
                    positions[i3 + 1] += Math.cos(time + i * 0.5) * 0.02;
                } else {
                    // Crystallized states vibrate slightly (Energy)
                    positions[i3]     += Math.sin(time * 3 + i) * 0.005;
                    positions[i3 + 1] += Math.cos(time * 2 + i) * 0.005;
                }
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;

            // 3. Scene Rotation (Parallax)
            particleSystem.rotation.y += 0.002; // Constant slow spin
            particleSystem.rotation.x += (mouseY - particleSystem.rotation.x) * 0.05;
            particleSystem.rotation.y += (mouseX - particleSystem.rotation.y) * 0.05;

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
